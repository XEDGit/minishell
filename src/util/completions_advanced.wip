#include <shared.h>
#include <dirent.h>

int count_items(char *path)
{
	struct dirent	*dir;
	DIR				*d;
	int				items = 0;

	d = opendir(path);
	if (d)
	{
		while ((dir = readdir(d)) != NULL)
		{
			if (dir->d_type != DT_REG)
				continue ;
			items++;
		}
		closedir(d);
	}
	return (items);
}

char	**completions_generator(t_env *newenv)
{
	static t_env	*env;
	char			**completions, *path, **paths;
	struct dirent	*dir;
	DIR				*d;
	int				path_i, comp_i = 0, total;

	if (newenv && (env = newenv))
		return (0);
	if (!env)
		return (0);
	total = 0;
	path = env_get(env, "PATH", 1);
	// count items in path
	if (path && *path)
	{
		paths = sk_split(path, ":");
		free(path);
		path = (char *)0x1;
		if (!paths)
			return ((char **)(long)error_int("malloc error", "autocomplete", -1, 0));
		path_i = 0;
		while (paths[path_i])
			total += count_items(paths[path_i++]);
	}
	else if (path && !*path)
	{
		free(path);
		path = 0;
	}
	// allocate completions
	completions = malloc(sizeof(char *) * (total + 1));
	if (!completions)
		return ((char **)(long)error_int("malloc error", "autocomplete", -1, 0));
	// fill in completions from path
	if (path)
	{
		path_i = 0;
		while (paths[path_i])
		{
			d = opendir(paths[path_i]);
			if (d)
			{
				while ((dir = readdir(d)) != NULL)
				{
					if (dir->d_type != DT_REG)
						continue;
					completions[comp_i] = sk_strdup(dir->d_name);
					if (!completions[comp_i++])
					{
						free2d(completions, 0);
						completions = 0;
						return ((char **)(long)error_int("malloc error", "autocomplete", -1, 0));
					}
				}
				closedir(d);
			}
			path_i++;
		}
		free2d(paths, 0);
	}
	completions[comp_i] = 0;
	return (completions);
}

char *match_completion(const char *text, int state)
{
	static int	i, len, choice = -1, return_index = 0, max_return_index = 0;
	char		*completion = 0;
	static char	**completions = 0;

	if (state == -1)
	{
		return_index = 0;
		choice = -1;
		if (completions)
			free2d(completions, 0);
		completions = 0;
		return (0);
	}
	if (!state)
	{
		return_index = 0;
		choice++;
		i = 0;
		len = sk_strlen(text);
	}
	if (state > max_return_index)
		max_return_index = state;
	if (choice == max_return_index)
		choice = 0;
	if (completions == 0)
		completions = completions_generator(0);
	if (!completions)
		return (0);
	while (completions[i])
	{
		if (*text == *completions[i] && !sk_strncmp(completions[i], text, len))
		{
			if (choice == return_index++)
				return (sk_strdup("         >"));
			completion = sk_strdup(completions[i]);
			i++;
			return (completion);
		}
		i++;
	}
	return (0);
}

bool	check_duplicates(char *test, char **matches)
{
	return (false);
}

bool	find_common_string(const char *text, char **matches, int cut)
{
	char	*buffer, *resized_match;
	int		i = 0, j = 0, len;

	// add case with no matches matches[0] = text(dup?)
	// check functioning of common string find
	len = sk_strlen(text) + cut;
	resized_match = sk_strdup(matches[i++]);
	resized_match[len] = 0;
	while (matches[j] && !sk_strncmp(resized_match, matches[j], len))
		j++;
	matches[0] = resized_match;
	if (matches[j])
		return (false);
	free(resized_match);
	find_common_string(text, matches, cut + 1);
	return (false);
}

char	**sk_completion_matches(const char *text, rl_compentry_func_t *func)
{
	char		**matches, *buffer;
	int			i = 0, tot = 0, state = 0, size_mult = 1;

	matches = malloc(50 * sizeof(char *));
	if (!matches)
		return (0);
	matches[0] = 0;
	while (true)
	{
		buffer = func(text, tot);
		if (!buffer)
			break ;
		if (check_duplicates(buffer, matches))
		{
			free(buffer);
			continue ;
		}
		matches[tot] = buffer;
		if (i == 50)
		{
			matches = sk_realloc(matches, 50 * size_mult, 50 * size_mult + 1);
			size_mult++;
			if (!matches)
				return (0);
			i = 0;
		}
		tot++;
		i++;
	}
	if (tot)
	{
		matches[tot] = 0;
		// find_common_string(text, matches, 0);
	}
	return (matches);
}

char **completion(const char *text, int start, int end)
{
	(void)start;
	(void)end;
	return (sk_completion_matches(text, match_completion));
}
